/* Generated By:JavaCC: Do not edit this line. TextFormatGrammar.java */
package edu.usc.ict.nl.dm.reward.model.textFormat;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Set;
import java.util.Stack;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import edu.usc.ict.nl.dm.reward.model.DialogueOperatorEffect;
import edu.usc.ict.nl.kb.DialogueKBFormula;
import edu.usc.ict.nl.util.StringUtils;
import edu.usc.ict.nl.util.XMLUtils;

/** Simple brace matcher. */
public class TextFormatGrammar implements TextFormatGrammarConstants {

  private static int sn=1;
  private static final String prefix="node";
  private static int getID() {return ++sn;}
  private static String getStateName(int n) {return prefix+n;}
  private static HashMap<Integer,String> allStates=new HashMap<Integer,String>();
  private static final int endState=getID();
  private HashMap<String,String> userMacros=null;

  private static final Pattern eventStringMacro=Pattern.compile("^[\u005c\u005cs]*[Oo][Rr][\u005c\u005cs]*\u005c\u005c((.+)\u005c\u005c)[\u005c\u005cs]*$");
  private List<String> getEvents(String es) {
        List<String> ret=new ArrayList<String>();
        Matcher m=eventStringMacro.matcher(es);
        if (m.matches()) {
                String listS=m.group(1);
                if (!StringUtils.isEmptyString(listS)) {
                        String[] list=listS.split(",");
                        for (String e:list) {
                                e=StringUtils.cleanupSpaces(e);
                                ret.add(e);
                        }
                } else {
                        ret.add(StringUtils.cleanupSpaces(es));
                }
        } else {
                ret.add(StringUtils.cleanupSpaces(es));
        }
        if (ret!=null && !ret.isEmpty() && userMacros!=null) {
                        Set<String> noRepeats=new LinkedHashSet<String>();
                Stack<String> events=new Stack<String>();
                events.addAll(ret);

                while(!events.isEmpty()) {
                        String e=events.pop();
                        String macro=getMacroFor(e);
                        if (!StringUtils.isEmptyString(macro)) {
                                events.addAll(getEvents(macro));
                        } else noRepeats.add(e);
                }
                ret.clear();
                ret.addAll(noRepeats);
        }
        return ret;
  }

  public void setUserMacros(HashMap<String,String> macros) {userMacros=macros;}
  private String getMacroFor(String e) {return (userMacros!=null)?userMacros.get(e):null;}

  private static void addTransitionToState(int sn,DialogueKBFormula cnd,int target,int line) throws ParseException {
        canAddOutgoingTransitionToState(sn,line);
        String content="";
        if (allStates.containsKey(sn)) content=allStates.get(sn);
        content+="<transition condition=\u005c""+((cnd!=null)?cnd.toString():"")+"\u005c" target=\u005c""+getStateName(target)+"\u005c"/>";
        allStates.put(sn,content);
  }
  private static void addListenToState(int sn,String event,DialogueKBFormula cnd,boolean ce,int target,int line) throws ParseException {
        canAddOutgoingTransitionToState(sn,line);
    if (StringUtils.isEmptyString(StringUtils.cleanupSpaces(event)))
        throw new ParseException("empty user argument at line "+line);
        String content="";
        if (allStates.containsKey(sn)) content=allStates.get(sn);
        content+="<listen event=\u005c""+StringUtils.cleanupSpaces(event)+"\u005c" target=\u005c""+getStateName(target)+"\u005c" condition=\u005c""+((cnd!=null)?cnd.toString():"")+"\u005c" consume=\u005c""+ce+"\u005c"/>";
        allStates.put(sn,content);
  }
  private static void addSayToState(int sn,String say,boolean interruptible,int target,int line) throws ParseException {
        canAddOutgoingTransitionToState(sn,line);
    if (StringUtils.isEmptyString(StringUtils.cleanupSpaces(say)))
        throw new ParseException("empty system argument at line "+line);
        String content="";
        if (allStates.containsKey(sn)) content=allStates.get(sn);
        content+="<say event=\u005c""+XMLUtils.escapeStringForXML(say)+"\u005c" target=\u005c""+getStateName(target)+"\u005c" interruptible=\u005c""+interruptible+"\u005c"/>";
        allStates.put(sn,content);
  }

  private static void canAddOutgoingTransitionToState(int sn,int line) throws ParseException {
        if (sn==endState) throw new ParseException("Trying to add outgoing edge to final state. Line: "+line);
  }

  private static void addToState(int sn,String add) {
        String content="";
        if (allStates.containsKey(sn)) content=allStates.get(sn);
        content+=add;
        allStates.put(sn,content);
  }

  /** Main entry point. */
  public static void main(String args[]) throws ParseException {
        try {
                TextFormatGrammar parser = new TextFormatGrammar(new java.io.FileInputStream(args[0]));
                parser.Input();
        } catch (java.io.FileNotFoundException e) { System.out.println("Java Parser Version 1.1: File " + args[0] + " not found."); return; }
  }

/** Root production. */
  final public String Input() throws ParseException {
        Token t;
        String n;
        String output="<networks>";
    label_1:
    while (true) {
      n = ReadNetwork();
                          output+=n;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case NETWORK:
      case FINAL:
      case DAEMON:
        ;
        break;
      default:
        jj_la1[0] = jj_gen;
        break label_1;
      }
    }
                                         {if (true) return output+"</networks>";}
    throw new Error("Missing return statement in function");
  }

  final public String ReadNetwork() throws ParseException {
        Token t,f=null,d=null,cnd=null;
        int cs=getID();
        int ns=getID();
        String output="";
        DialogueKBFormula cndf=null;
                allStates.clear();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case FINAL:
      f = jj_consume_token(FINAL);
      break;
    default:
      jj_la1[1] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case DAEMON:
      d = jj_consume_token(DAEMON);
      break;
    default:
      jj_la1[2] = jj_gen;
      ;
    }
    jj_consume_token(NETWORK);
    t = jj_consume_token(ID);
    jj_consume_token(LBRACE);
        if ((f!=null) && (d!=null)) {if (true) throw new ParseException("Invalid final daemon network at line "+f.beginLine+" column: "+f.beginColumn);}
                output="<network id=\u005c""+t.image+"\u005c" "+
                        ((f!=null)?"final=\u005c"true\u005c" ":"final=\u005c"false\u005c" ")+
                        ((d!=null)?"daemon=\u005c"true\u005c" ":"daemon=\u005c"false\u005c" ")+
                        ">";
    label_2:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case VAR:
      case GOAL:
      case SEND:
      case FORGET:
      case TTCND:
      case TOPIC:
      case EC:
      case GV:
      case RO:
      case IS:
      case IGNORE:
        ;
        break;
      default:
        jj_la1[3] = jj_gen;
        break label_2;
      }
      CurrentStateAnnotation(ns,cs,true);
    }
    label_3:
    while (true) {
      ns = ReadBlock(ns,cs);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LBRACE:
      case USER:
      case SYSTEM:
      case ISYSTEM:
      case GOTOEND:
      case NOP:
      case IF:
        ;
        break;
      default:
        jj_la1[4] = jj_gen;
        break label_3;
      }
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case END:
      jj_consume_token(END);
      label_4:
      while (true) {
        CurrentStateAnnotation(endState,cs,false);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case VAR:
        case GOAL:
        case SEND:
        case FORGET:
        case TTCND:
        case TOPIC:
        case EC:
        case GV:
        case RO:
        case IS:
        case IGNORE:
          ;
          break;
        default:
          jj_la1[5] = jj_gen;
          break label_4;
        }
      }
      break;
    default:
      jj_la1[6] = jj_gen;
      ;
    }
    jj_consume_token(RBRACE);
                if (ns!=endState) addTransitionToState(ns,null,endState,0);
                for(int i=0;i<=sn;i++) {
                        if (allStates.containsKey(i)) {
                                if (i==cs) {
                                        output+=allStates.get(i);
                                } else {
                                        output+="<state id=\u005c""+getStateName(i)+"\u005c">\u005cn";
                                        output+=allStates.get(i);
                                        output+="</state>\u005cn";
                                }
                        }
                }
                output+="</network>\u005cn";
                {if (true) return output;}
    throw new Error("Missing return statement in function");
  }

  final public int ReadBlock(int cs,int ss) throws ParseException {
        int ns=cs;
        int ns2;
        int startThen,endThen,startElse=-1,endElse=-1,endIf=-1;
        Token cnd=null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LBRACE:
      cnd = jj_consume_token(LBRACE);
      label_5:
      while (true) {
        ns = ReadBlock(ns,ss);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case LBRACE:
        case USER:
        case SYSTEM:
        case ISYSTEM:
        case GOTOEND:
        case NOP:
        case IF:
          ;
          break;
        default:
          jj_la1[7] = jj_gen;
          break label_5;
        }
      }
      jj_consume_token(RBRACE);
      label_6:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case VAR:
        case GOAL:
        case SEND:
        case FORGET:
        case TTCND:
        case TOPIC:
        case EC:
        case GV:
        case RO:
        case IS:
        case IGNORE:
          ;
          break;
        default:
          jj_la1[8] = jj_gen;
          break label_6;
        }
        CurrentStateAnnotation(ns,ss,false);
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OR:
        jj_consume_token(OR);
        ns2 = ReadBlock(cs,ss);
                if (ns!=endState) {
                        addTransitionToState(ns,null,ns=getID(),cnd.beginLine);
                        if (ns2!=endState) {
                                addTransitionToState(ns2,null,ns,cnd.beginLine);
                        }
                        addToState(ns,"");
                } else {
                        ns=ns2;
                }
        break;
      default:
        jj_la1[9] = jj_gen;
        ;
      }
              {if (true) return ns;}
      break;
    case USER:
    case SYSTEM:
    case ISYSTEM:
    case GOTOEND:
      ns = ReadTerminalBlock(cs,ss);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OR:
        cnd = jj_consume_token(OR);
        ns2 = ReadBlock(cs,ss);
                addTransitionToState(ns,null,ns=getID(),cnd.beginLine);
                addTransitionToState(ns2,null,ns,cnd.beginLine);
                addToState(ns,"");
        break;
      default:
        jj_la1[10] = jj_gen;
        ;
      }
              {if (true) return ns;}
      break;
    case IF:
      jj_consume_token(IF);
      cnd = jj_consume_token(ANY);
      jj_consume_token(ENDTEXT);
      endThen = readIfBody(startThen=getID(),ss);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ELSE:
        jj_consume_token(ELSE);
        endElse = readIfBody(startElse=getID(),ss);
        break;
      default:
        jj_la1[11] = jj_gen;
        ;
      }
                try {
                        DialogueKBFormula f=DialogueKBFormula.parse(cnd.image);
                        addTransitionToState(cs,f,startThen,cnd.beginLine);
                } catch (Exception e) {{if (true) throw new ParseException("Invalid condition: "+cnd.image+" at line "+cnd.beginLine+" column: "+cnd.beginColumn);}}
                if ((endThen!=endState) || (endElse!=endState)) endIf=getID();
                if (startElse>0) {
                        addTransitionToState(cs,null,startElse,cnd.beginLine);
                        if (endElse!=endState) {
                                addTransitionToState(endElse,null,endIf,cnd.beginLine);
                        }
                } else {
                        addTransitionToState(cs,null,endIf,cnd.beginLine);
                }
                if (endThen!=endState) {
                        addTransitionToState(endThen,null,endIf,cnd.beginLine);
                }
                {if (true) return (endIf>0)?endIf:endState;}
      break;
    case NOP:
      cnd = jj_consume_token(NOP);
      label_7:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case VAR:
        case GOAL:
        case SEND:
        case FORGET:
        case TTCND:
        case TOPIC:
        case EC:
        case GV:
        case RO:
        case IS:
        case IGNORE:
          ;
          break;
        default:
          jj_la1[12] = jj_gen;
          break label_7;
        }
        CurrentStateAnnotation(cs,ss,false);
      }
                addTransitionToState(ns,null,ns=getID(),cnd.beginLine);
                {if (true) return ns;}
      break;
    default:
      jj_la1[13] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public int readIfBody(int cs,int ss) throws ParseException {
        int ns=cs;
        int ns2;
        int startThen,endThen,startElse=-1,endElse=-1,endIf=-1;
        Token cnd=null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LBRACE:
      cnd = jj_consume_token(LBRACE);
      label_8:
      while (true) {
        ns = ReadBlock(ns,ss);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case LBRACE:
        case USER:
        case SYSTEM:
        case ISYSTEM:
        case GOTOEND:
        case NOP:
        case IF:
          ;
          break;
        default:
          jj_la1[14] = jj_gen;
          break label_8;
        }
      }
      jj_consume_token(RBRACE);
                                                        {if (true) return ns;}
      break;
    case USER:
    case SYSTEM:
    case ISYSTEM:
    case GOTOEND:
      ns = ReadTerminalBlock(cs,ss);
                                       {if (true) return ns;}
      break;
    case IF:
      jj_consume_token(IF);
      cnd = jj_consume_token(ANY);
      jj_consume_token(ENDTEXT);
      endThen = readIfBody(startThen=getID(),ss);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ELSE:
        jj_consume_token(ELSE);
        endElse = readIfBody(startElse=getID(),ss);
        break;
      default:
        jj_la1[15] = jj_gen;
        ;
      }
                try {
                        DialogueKBFormula f=DialogueKBFormula.parse(cnd.image);
                        addTransitionToState(cs,f,startThen,cnd.beginLine);
                } catch (Exception e) {{if (true) throw new ParseException("Invalid condition: "+cnd.image+" at line "+cnd.beginLine+" column: "+cnd.beginColumn);}}
                if ((endThen!=endState) || (endElse!=endState)) endIf=getID();
                if (startElse>0) {
                        addTransitionToState(cs,null,startElse,cnd.beginLine);
                        if (endElse!=endState) {
                                addTransitionToState(endElse,null,endIf,cnd.beginLine);
                        }
                } else {
                        addTransitionToState(cs,null,endIf,cnd.beginLine);
                }
                if (endThen!=endState) {
                        addTransitionToState(endThen,null,endIf,cnd.beginLine);
                }
                {if (true) return (endIf>0)?endIf:endState;}
      break;
    case NOP:
      cnd = jj_consume_token(NOP);
      label_9:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case VAR:
        case GOAL:
        case SEND:
        case FORGET:
        case TTCND:
        case TOPIC:
        case EC:
        case GV:
        case RO:
        case IS:
        case IGNORE:
          ;
          break;
        default:
          jj_la1[16] = jj_gen;
          break label_9;
        }
        CurrentStateAnnotation(cs,ss,false);
      }
                addTransitionToState(ns,null,ns=getID(),cnd.beginLine);
                {if (true) return ns;}
      break;
    default:
      jj_la1[17] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public int ReadTerminalBlock(int cs,int ss) throws ParseException {
        int ns;
        Token pos;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case USER:
    case SYSTEM:
    case ISYSTEM:
      ns = ReadEdge(cs);
      label_10:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case VAR:
        case GOAL:
        case SEND:
        case FORGET:
        case TTCND:
        case TOPIC:
        case EC:
        case GV:
        case RO:
        case IS:
        case IGNORE:
          ;
          break;
        default:
          jj_la1[18] = jj_gen;
          break label_10;
        }
        CurrentStateAnnotation(ns,ss,false);
      }
                                                                  {if (true) return ns;}
      break;
    case GOTOEND:
      pos = jj_consume_token(GOTOEND);
                addTransitionToState(cs,null,endState,pos.beginLine);
                {if (true) return endState;}
      break;
    default:
      jj_la1[19] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public int ReadEdge(int cs) throws ParseException {
        int ns=getID();
        Token say=null;
        Token cnd=null;
        Token ce=null;
        String ret;
        List<String> events;
        DialogueKBFormula f=null;
        Token pos;
        boolean interruptible=false;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case USER:
      pos = jj_consume_token(USER);
      say = jj_consume_token(ANY);
      jj_consume_token(ENDTEXT);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case CONDITION:
      case CE:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case CONDITION:
          jj_consume_token(CONDITION);
          cnd = jj_consume_token(ANY);
          jj_consume_token(ENDTEXT);
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case CE:
            ce = jj_consume_token(CE);
            break;
          default:
            jj_la1[20] = jj_gen;
            ;
          }
          break;
        case CE:
          ce = jj_consume_token(CE);
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case CONDITION:
            jj_consume_token(CONDITION);
            cnd = jj_consume_token(ANY);
            jj_consume_token(ENDTEXT);
            break;
          default:
            jj_la1[21] = jj_gen;
            ;
          }
          break;
        default:
          jj_la1[22] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
      default:
        jj_la1[23] = jj_gen;
        ;
      }
                events=getEvents(say.image);
                if (cnd!=null) {
                        try {
                                f=DialogueKBFormula.parse(cnd.image);
                        } catch (Exception e) {{if (true) throw new ParseException("Invalid condition: "+cnd+" at line "+cnd.beginLine+" column: "+cnd.beginColumn);}}
                }
                if (events.size()==1) {
                        String event=events.get(0);
                        addListenToState(cs,event,f,(ce!=null),ns,pos.beginLine);
                        addToState(ns,"");
                        {if (true) return ns;}
                } else {
                        for(String event: events) {
                                int ms=getID();
                                addListenToState(cs,event,f,(ce!=null),ms,pos.beginLine);
                                addTransitionToState(ms,null,ns,pos.beginLine);
                        }
                        addToState(ns,"");
                        {if (true) return ns;}
                }
      break;
    case SYSTEM:
    case ISYSTEM:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SYSTEM:
        pos = jj_consume_token(SYSTEM);
        break;
      case ISYSTEM:
        pos = jj_consume_token(ISYSTEM);
                                         interruptible=true;
        break;
      default:
        jj_la1[24] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      say = jj_consume_token(ANY);
      jj_consume_token(ENDTEXT);
                events=getEvents(say.image);
                if (events.size()==1) {
                        String event=events.get(0);
                        addSayToState(cs,event,interruptible,ns,pos.beginLine);
                        addToState(ns,"");
                        {if (true) return ns;}
                } else {
                        for(String event: events) {
                                int ms=getID();
                                addSayToState(cs,event,interruptible,ms,pos.beginLine);
                                addTransitionToState(ms,null,ns,pos.beginLine);
                        }
                        addToState(ns,"");
                        {if (true) return ns;}
                }
      break;
    default:
      jj_la1[25] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public void CurrentStateAnnotation(int cs,int ss,boolean isRoot) throws ParseException {
        Token t1=null,t2=null,cnd=null,forget=null;
        boolean si=false;
        String ret="",varGoalName,action="";
        DialogueKBFormula value,f;
        DialogueOperatorEffect a=null;
        DialogueKBFormula cndf=null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case VAR:
      jj_consume_token(VAR);
      t1 = jj_consume_token(ANY);
      jj_consume_token(ENDTEXT);
                try {
                        a=DialogueOperatorEffect.parse(t1.image);
                        if (!a.isAssignment()) {if (true) throw new Exception();}
                } catch (Exception e) {{if (true) throw new ParseException("Invalid variable assignment: "+t1.image+" at line "+t1.beginLine+" column: "+t1.beginColumn);}}
                ret="<var id=\u005c""+a.getAssignedVariable()+"\u005c" value=\u005c""+a.getAssignedExpression()+"\u005c"/>";
                addToState((isRoot)?ss:cs,ret+"\u005cn");
      break;
    case EC:
      jj_consume_token(EC);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case UI:
        jj_consume_token(UI);
                     si=false;
        t1 = jj_consume_token(ANY);
        jj_consume_token(ENDTEXT);
        break;
      case SI:
        jj_consume_token(SI);
                                                          si=true;
        break;
      default:
        jj_la1[26] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case CONDITION:
        jj_consume_token(CONDITION);
        cnd = jj_consume_token(ANY);
        jj_consume_token(ENDTEXT);
        break;
      default:
        jj_la1[27] = jj_gen;
        ;
      }
                //<ec event="current-user-speech-act(login)" target="welcome-user"/>
                //<ec event="system-initiative" condition="and(~got-symptom,timeSinceLastAction>=30)" target="start"/>		
                ret="<ec event=";
                if (si) ret+="\u005c"system-initiative\u005c" ";
                else ret+="\u005c"current-user-speech-act("+StringUtils.cleanupSpaces(t1.image)+")\u005c" ";
                if (cnd!=null) {
                        try {
                                f=DialogueKBFormula.parse(cnd.image);
                                ret+="condition=\u005c""+f.toString()+"\u005c" ";
                        } catch (Exception e) {{if (true) throw new ParseException("Invalid condition: "+cnd.image+" at line "+cnd.beginLine+" column: "+cnd.beginColumn);}}
                }
                ret+="target=\u005c""+getStateName(cs)+"\u005c" />";
                addToState(ss,ret+"\u005cn");
      break;
    case RO:
      jj_consume_token(RO);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ANY:
        t1 = jj_consume_token(ANY);
        break;
      default:
        jj_la1[28] = jj_gen;
        ;
      }
      jj_consume_token(ENDTEXT);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case CONDITION:
        jj_consume_token(CONDITION);
        cnd = jj_consume_token(ANY);
        jj_consume_token(ENDTEXT);
        break;
      default:
        jj_la1[29] = jj_gen;
        ;
      }
                ret="<ec event=\u005c"reentrance-option\u005c" say=\u005c""+((t1!=null)?t1.image:"")+"\u005c" target=\u005c""+getStateName(cs)+"\u005c"";
                if (cnd!=null) {
                        try {
                                f=DialogueKBFormula.parse(cnd.image);
                                ret+=" condition=\u005c""+f.toString()+"\u005c" ";
                        } catch (Exception e) {{if (true) throw new ParseException("Invalid condition: "+cnd.image+" at line "+cnd.beginLine+" column: "+cnd.beginColumn);}}
                }
                ret+="/>";
                addToState(ss,ret+"\u005cn");
      break;
    case GOAL:
      jj_consume_token(GOAL);
      t1 = jj_consume_token(ID);
                         token_source.SwitchTo(TEXT);t2=null;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ANY:
        t2 = jj_consume_token(ANY);
        break;
      default:
        jj_la1[30] = jj_gen;
        ;
      }
      jj_consume_token(ENDTEXT);
                f=null;
                if (t2!=null) {
                        try {
                                f=DialogueKBFormula.parse(t2.image);
                        } catch (Exception e) {{if (true) throw new ParseException("Invalid goal expression: '"+t2.image+"' at line "+t2.beginLine+" column: "+t2.beginColumn);}}
                }
                if (f!=null) {
                        ret="<effect goal=\u005c""+t1.image+"\u005c" expr=\u005c""+t2.image+"\u005c"/>";
                } else {
                        ret="<effect goal=\u005c""+t1.image+"\u005c" expr=\u005c"\u005c"/>";
                }
                addToState(cs,ret+"\u005cn");
      break;
    case SEND:
      jj_consume_token(SEND);
      t1 = jj_consume_token(ID);
                ret="<send id=\u005c""+t1.image+"\u005c"/>";
                addToState(cs,ret+"\u005cn");
      break;
    case IS:
      jj_consume_token(IS);
      t1 = jj_consume_token(ANY);
      jj_consume_token(ENDTEXT);
                if (StringUtils.isEmptyString(action=StringUtils.cleanupSpaces(t1.image)))
                        {if (true) throw new ParseException("empty information state update/action at line "+t1.beginLine+" column: "+t1.beginColumn);}
                else {
                        if (action.toLowerCase().equals("swapout")) {
                                ret="<swapout/>";
                        } else if (action.toLowerCase().equals("interrupt")) {
                                ret="<interrupt/>";
                        } else {
                                try {
                                        a=DialogueOperatorEffect.parse(action);
                                        if (!a.isAssignment()) {if (true) throw new Exception();}
                                } catch (Exception e) {{if (true) throw new ParseException("Invalid information state update: "+t1.image+" at line "+t1.beginLine+" column: "+t1.beginColumn);}}
                                ret="<effect expr=\u005c""+a.toString()+"\u005c"/>";
                        }
                        addToState(cs,ret+"\u005cn");
                }
      break;
    case GV:
      jj_consume_token(GV);
      t1 = jj_consume_token(ANY);
      jj_consume_token(ENDTEXT);
                try {
                        a=DialogueOperatorEffect.parse(t1.image);
                        if (!a.isAssignment()) {if (true) throw new Exception();}
                        varGoalName=DialogueOperatorEffect.buildVarNameForGoal(a.getAssignedVariable().getName());
                    value=(DialogueKBFormula) a.getAssignedExpression();
                        value=DialogueOperatorEffect.processGoalExpression(value,varGoalName);
                        ret="<effect expr=\u005c"Assign("+varGoalName+","+value+")\u005c"/>";
                        addToState(cs,ret+"\u005cn");
                } catch (Exception e) { {if (true) throw new ParseException("Error while parsing goal value directive: "+t1.image+" at line "+t1.beginLine+" column: "+t1.beginColumn);}}
      break;
    case TOPIC:
      jj_consume_token(TOPIC);
      t1 = jj_consume_token(ID);
                ret+="<topic id=\u005c""+t1.image+"\u005c" />";
                addToState(ss,ret+"\u005cn");
      break;
    case FORGET:
      jj_consume_token(FORGET);
      forget = jj_consume_token(ANY);
      jj_consume_token(ENDTEXT);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case CONDITION:
        jj_consume_token(CONDITION);
        cnd = jj_consume_token(ANY);
        jj_consume_token(ENDTEXT);
        break;
      default:
        jj_la1[31] = jj_gen;
        ;
      }
                cndf=null;
                Integer forgetTime=0;
                if (cnd!=null) {
                        try {
                                cndf=DialogueKBFormula.parse(cnd.image);
                        } catch (Exception e) {{if (true) throw new ParseException("Invalid condition: "+cnd.image+" at line "+cnd.beginLine+" column: "+cnd.beginColumn);}}
                        if (forget!=null) {
                                forgetTime=Integer.parseInt(forget.image);
                                if (forgetTime<0) {if (true) throw new ParseException("negative forget time at line: "+forget.beginLine+" column: "+forget.beginColumn);}
                                ret+="<forget time=\u005c""+forgetTime+"\u005c" cnd=\u005c""+cndf.toString()+"\u005c"/>";
                                addToState(ss,ret+"\u005cn");
                        }
                }
      break;
    case TTCND:
      jj_consume_token(TTCND);
      cnd = jj_consume_token(ANY);
      jj_consume_token(ENDTEXT);
                cndf=null;
                if (cnd!=null) {
                        try {
                                cndf=DialogueKBFormula.parse(cnd.image);
                                ret+="<turntakingcnd cnd=\u005c""+cndf.toString()+"\u005c"/>";
                                addToState(ss,ret+"\u005cn");
                        } catch (Exception e) {{if (true) throw new ParseException("Invalid condition: "+cnd.image+" at line "+cnd.beginLine+" column: "+cnd.beginColumn);}}
                }
      break;
    case IGNORE:
      jj_consume_token(IGNORE);
      t1 = jj_consume_token(ID);
                ret+="<ignore id=\u005c""+t1.image+"\u005c" />";
                addToState(ss,ret+"\u005cn");
      break;
    default:
      jj_la1[32] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  /** Generated Token Manager. */
  public TextFormatGrammarTokenManager token_source;
  SimpleCharStream jj_input_stream;
  /** Current token. */
  public Token token;
  /** Next token. */
  public Token jj_nt;
  private int jj_ntk;
  private int jj_gen;
  final private int[] jj_la1 = new int[33];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static {
      jj_la1_init_0();
      jj_la1_init_1();
   }
   private static void jj_la1_init_0() {
      jj_la1_0 = new int[] {0xc0000000,0x80000000,0x0,0x391f8000,0xe00200,0x391f8000,0x0,0xe00200,0x391f8000,0x0,0x0,0x0,0x391f8000,0xe00200,0xe00200,0x0,0x391f8000,0xe00200,0x391f8000,0xe00000,0x0,0x0,0x0,0x0,0xc00000,0xe00000,0x6000000,0x0,0x0,0x0,0x0,0x0,0x391f8000,};
   }
   private static void jj_la1_init_1() {
      jj_la1_1 = new int[] {0x1,0x0,0x1,0x400,0xe0,0x400,0x10,0xe0,0x400,0x8,0x8,0x100,0x400,0xe0,0xe0,0x100,0x400,0xe0,0x400,0x20,0x4,0x2,0x6,0x6,0x0,0x0,0x0,0x2,0x4000,0x2,0x4000,0x2,0x400,};
   }

  /** Constructor with InputStream. */
  public TextFormatGrammar(java.io.InputStream stream) {
     this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public TextFormatGrammar(java.io.InputStream stream, String encoding) {
    try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new TextFormatGrammarTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 33; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 33; i++) jj_la1[i] = -1;
  }

  /** Constructor. */
  public TextFormatGrammar(java.io.Reader stream) {
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new TextFormatGrammarTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 33; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 33; i++) jj_la1[i] = -1;
  }

  /** Constructor with generated Token Manager. */
  public TextFormatGrammar(TextFormatGrammarTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 33; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(TextFormatGrammarTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 33; i++) jj_la1[i] = -1;
  }

  private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }


/** Get the next Token. */
  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

/** Get the specific Token. */
  final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
  private int[] jj_expentry;
  private int jj_kind = -1;

  /** Generate ParseException. */
  public ParseException generateParseException() {
    jj_expentries.clear();
    boolean[] la1tokens = new boolean[49];
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 33; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 49; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.add(jj_expentry);
      }
    }
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = jj_expentries.get(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  /** Enable tracing. */
  final public void enable_tracing() {
  }

  /** Disable tracing. */
  final public void disable_tracing() {
  }

}
